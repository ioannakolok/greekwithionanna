<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frage 8 – Griechenland‑Quiz</title>
    <!-- Google Fonts & Tailwind CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600&family=Crimson+Text:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'aegean-blue': '#1E3A8A',
                        'santorini-white': '#FEFEFE',
                        'olive-gold': '#D97706',
                        'marble-gray': '#6B7280',
                        'terracotta': '#DC2626'
                    },
                    fontFamily: {
                        'display': ['Playfair Display','serif'],
                        'body': ['Inter','sans-serif'],
                        'accent': ['Crimson Text','serif']
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="assets/css/style.css">
    <style>
        /* Map overlay styles */
        .map-container {
            position: relative;
            /* Fill the available width on mobile while maintaining aspect ratio */
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
        }
        .map-container img {
            width: 100%;
            height: auto;
            display: block;
        }
        .place-label {
            position: absolute;
            transform: translate(-50%, -50%);
            font-size: 0.85rem;
            font-weight: 500;
            color: #1E3A8A;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            border-radius: 4px;
            pointer-events: none;
        }
        /* Drop zones overlay the map in game mode */
        .dropzone {
            position: absolute;
            transform: translate(-50%, -50%);
            /* Further enlarge the drop area for easier mobile interaction */
            width: 180px;
            height: 45px;
            border: 1px dashed #6B7280;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.95rem;
            background: rgba(255,255,255,0.9);
        }
        .dropzone.correct {
            border-color: #10B981; /* green */
            background: rgba(209,250,229,0.8);
        }
        .dropzone.incorrect {
            border-color: #DC2626; /* red */
            background: rgba(254,202,202,0.8);
        }
        .draggable-name {
            cursor: grab;
            user-select: none;
            padding: 6px 8px;
            margin: 4px;
            background: #EFF6FF;
            border: 1px solid #BFDBFE;
            border-radius: 4px;
            font-size: 0.85rem;
            display: inline-block;
        }
        .draggable-name:active {
            cursor: grabbing;
        }

        /* On smaller screens reduce the size of the drop zones for better fit */
        @media (max-width: 640px) {
            .dropzone {
                width: 100px;
                height: 32px;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body class="font-body bg-santorini-white">
    <!-- Navigation -->
    <nav class="fixed top-0 w-full bg-white/95 backdrop-blur-sm z-50 border-b border-gray-100">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center">
                    <h1 class="text-xl font-display font-semibold text-aegean-blue">LearnGreek.eu</h1>
                </div>
                <div class="hidden md:block">
                    <div class="ml-10 flex items-baseline space-x-8">
                        <a href="../index.html" class="text-marble-gray hover:text-aegean-blue px-1 py-2">Home</a>
                        <a href="quiz.html" class="text-aegean-blue font-medium border-b-2 border-olive-gold px-1 py-2">Quiz</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>
    <!-- Main content -->
    <main class="mt-20 py-10">
        <div class="max-w-3xl mx-auto px-4">
            <h2 class="text-3xl md:text-4xl font-display font-semibold text-aegean-blue mb-4">Frage 8: Reise durch Griechenland</h2>
            <!-- Study section with names -->
            <section id="study-section">
                <p class="text-marble-gray mb-6">Präg dir die Orte auf der Karte ein, gleich fehlen die Namen! Drücke auf „Weiter“, um die Karte ohne Namen zu sehen, zieh sie an die richtigen Pins und gehe danach zurück, um deine Antworten selbst zu kontrollieren.</p>
                <div class="map-container mb-6">
                    <!-- Show the uploaded map with names without adding overlays -->
                    <img src="assets/images/greece_with_names.jpeg" alt="Karte von Griechenland mit Beschriftung">
                </div>
                    <div class="mt-6 flex justify-between">
                        <a href="q7.html" class="nav-btn">Zurück</a>
                        <!-- Use an inline onclick handler to ensure the sections toggle even if JS fails to bind -->
                        <button type="button" id="to-game" class="nav-btn" onclick="document.getElementById('study-section').classList.add('hidden'); document.getElementById('game-section').classList.remove('hidden');">Weiter</button>
                    </div>
            </section>
            <!-- Game section hidden initially -->
            <section id="game-section" class="hidden">
                <p class="text-marble-gray mb-4">Ziehe die Ortsnamen aus der Liste an die richtigen Pins auf der Karte. Wenn du fertig bist, kannst du zurückgehen, um deine Antworten zu überprüfen.</p>
                <div class="map-container mb-4">
                    <img src="assets/images/greece_no_names.jpeg" alt="Karte von Griechenland ohne Beschriftung">
                    <!-- Drop zones corresponding to each place -->
                    <div class="dropzone" data-place="Thessaloniki" style="top:14%; left:49%;"></div>
                    <div class="dropzone" data-place="Korfu" style="top:33%; left:9%;"></div>
                    <div class="dropzone" data-place="Delphi" style="top:42%; left:39%;"></div>
                    <div class="dropzone" data-place="Athen" style="top:53%; left:50%;"></div>
                    <div class="dropzone" data-place="Olympia" style="top:57%; left:28%;"></div>
                    <div class="dropzone" data-place="Santorini" style="top:73%; left:55%;"></div>
                    <!-- Adjust the drop zones for Rhodos and Kreta slightly lower so they align better with the island locations -->
                    <div class="dropzone" data-place="Rhodos" style="top:86%; left:87%;"></div>
                    <div class="dropzone" data-place="Kreta" style="top:94%; left:45%;"></div>
                </div>
                <!-- Draggable names -->
                <div class="mb-6 flex flex-wrap justify-center gap-2" id="names-container">
                    <div class="draggable-name" draggable="true" data-place="Thessaloniki">Thessaloniki – Θεσσαλονίκη</div>
                    <div class="draggable-name" draggable="true" data-place="Korfu">Korfu – Κέρκυρα</div>
                    <div class="draggable-name" draggable="true" data-place="Delphi">Delphi – Δελφοί</div>
                    <div class="draggable-name" draggable="true" data-place="Athen">Athen – Αθήνα</div>
                    <div class="draggable-name" draggable="true" data-place="Olympia">Olympia – Ολυμπία</div>
                    <div class="draggable-name" draggable="true" data-place="Santorini">Santorini – Σαντορίνη</div>
                    <div class="draggable-name" draggable="true" data-place="Rhodos">Rhodos – Ρόδος</div>
                    <div class="draggable-name" draggable="true" data-place="Kreta">Kreta – Κρήτη</div>
                </div>
                <div class="mt-6 flex justify-between">
                    <!-- Inline handler to return to the study section -->
                    <button type="button" id="back-to-study" class="nav-btn" onclick="document.getElementById('game-section').classList.add('hidden'); document.getElementById('study-section').classList.remove('hidden');">Zurück</button>
                    <a href="results.html" class="nav-btn">Ergebnis</a>
                </div>
            </section>
        </div>
    </main>
    <script>
    // Toggle between study and game sections
    document.addEventListener('DOMContentLoaded', function() {
        const study = document.getElementById('study-section');
        const game = document.getElementById('game-section');
        const toGameBtn = document.getElementById('to-game');
        const backBtn = document.getElementById('back-to-study');
        toGameBtn.addEventListener('click', function() {
            study.classList.add('hidden');
            game.classList.remove('hidden');
        });
        backBtn.addEventListener('click', function() {
            game.classList.add('hidden');
            study.classList.remove('hidden');
        });
        /*
         * Custom drag‑and‑drop logic for the map task. The native HTML drag
         * API works poorly on mobile devices and does not provide clear
         * visual feedback. To mirror the intuitive behaviour implemented
         * in question 1, we disable native dragging on the place labels
         * and implement our own handling using pointer and touch events.
         */
        const draggables = document.querySelectorAll('.draggable-name');
        const dropzones = document.querySelectorAll('.dropzone');
        // Disable the built‑in draggable attribute to prevent the browser’s default behaviour
        draggables.forEach(el => {
            el.setAttribute('draggable', 'false');
        });

        // Helper to handle drops: places the text in the drop zone and removes the original
        function handleDrop(place, target) {
            // Only allow placement if the dropzone is empty
            if (target.textContent.trim() !== '') return;
            if (place === target.dataset.place) {
                target.textContent = place;
                target.classList.remove('incorrect');
                target.classList.add('correct');
                // Remove original label from the list
                const origin = document.querySelector('.draggable-name[data-place="' + place + '"]');
                if (origin) origin.remove();
            } else {
                // Wrong drop: briefly highlight in red
                target.classList.add('incorrect');
                setTimeout(() => {
                    target.classList.remove('incorrect');
                }, 800);
            }
        }

        // Pointer‑based dragging for mouse/stylus
        draggables.forEach(el => {
            el.addEventListener('pointerdown', function(ev) {
                // Do not start our custom drag on touch devices; touch handling below
                if (ev.pointerType === 'touch') return;
                ev.preventDefault();
                const place = this.dataset.place;
                // Create a floating clone that follows the pointer
                const clone = this.cloneNode(true);
                clone.classList.add('dragging');
                clone.style.position = 'fixed';
                clone.style.zIndex = '1000';
                clone.style.pointerEvents = 'none';
                document.body.appendChild(clone);
                const updatePosition = (e) => {
                    clone.style.left = (e.clientX - clone.offsetWidth / 2) + 'px';
                    clone.style.top = (e.clientY - clone.offsetHeight / 2) + 'px';
                };
                updatePosition(ev);
                const moveHandler = (e) => {
                    updatePosition(e);
                };
                const upHandler = (e) => {
                    document.removeEventListener('pointermove', moveHandler);
                    document.removeEventListener('pointerup', upHandler);
                    // Determine drop target
                    const targetElem = document.elementFromPoint(e.clientX, e.clientY);
                    let dropTarget = targetElem;
                    while (dropTarget && !dropTarget.classList.contains('dropzone') && dropTarget !== document.body) {
                        dropTarget = dropTarget.parentElement;
                    }
                    if (dropTarget && dropTarget.classList.contains('dropzone')) {
                        handleDrop(place, dropTarget);
                    }
                    clone.remove();
                };
                document.addEventListener('pointermove', moveHandler);
                document.addEventListener('pointerup', upHandler);
            });
        });

        // Detect touch devices
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            draggables.forEach(el => {
                el.addEventListener('touchstart', function(ev) {
                    if (!ev.touches || ev.touches.length > 1) return;
                    ev.preventDefault();
                    const place = this.dataset.place;
                    // Create floating clone
                    const clone = this.cloneNode(true);
                    clone.classList.add('dragging');
                    clone.style.position = 'fixed';
                    clone.style.zIndex = '1000';
                    clone.style.pointerEvents = 'none';
                    document.body.appendChild(clone);
                    function positionClone(touch) {
                        clone.style.left = (touch.clientX - clone.offsetWidth / 2) + 'px';
                        clone.style.top = (touch.clientY - clone.offsetHeight / 2) + 'px';
                    }
                    positionClone(ev.touches[0]);
                    const moveFn = function(moveEvent) {
                        if (moveEvent.touches && moveEvent.touches[0]) {
                            positionClone(moveEvent.touches[0]);
                        }
                    };
                    const endFn = function(endEvent) {
                        document.removeEventListener('touchmove', moveFn);
                        document.removeEventListener('touchend', endFn);
                        document.removeEventListener('touchcancel', endFn);
                        const touch = endEvent.changedTouches[0];
                        let targetElem = document.elementFromPoint(touch.clientX, touch.clientY);
                        let dropTarget = targetElem;
                        while (dropTarget && !dropTarget.classList.contains('dropzone') && dropTarget !== document.body) {
                            dropTarget = dropTarget.parentElement;
                        }
                        if (dropTarget && dropTarget.classList.contains('dropzone')) {
                            handleDrop(place, dropTarget);
                        }
                        clone.remove();
                    };
                    document.addEventListener('touchmove', moveFn, { passive: false });
                    document.addEventListener('touchend', endFn);
                    document.addEventListener('touchcancel', endFn);
                }, { passive: false });
            });
        }
    });
    </script>
</body>
</html>